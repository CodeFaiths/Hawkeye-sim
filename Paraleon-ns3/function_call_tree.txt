================================================================================
                    Paraleon NS-3 函数调用树
================================================================================

程序入口: scratch/third.cc::main()

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段1: 配置读取和初始化                                                  │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ [内联] 读取配置文件 (第492-809行)
│   ├─→ 解析 ENABLE_QCN, CC_MODE, U_TARGET 等参数
│   └─→ 设置全局变量
│
├─→ delete_files() [第442行]
│   └─→ 删除旧的追踪文件
│
└─→ Config::SetDefault() [设置NS-3默认配置]

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段2: 网络拓扑构建                                                      │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ 打开文件
│   ├─→ topof.open(topology_file)
│   ├─→ flowf.open(flow_file)
│   └─→ tracef.open(trace_file)
│
├─→ 创建节点 (第857-872行)
│   ├─→ CreateObject<Node>()          [主机节点]
│   └─→ CreateObject<SwitchNode>()     [交换机节点]
│
├─→ InternetStackHelper::Install() [安装IP协议栈]
│
├─→ 创建链路和网络设备 (第906-970行)
│   ├─→ QbbHelper::Install()
│   │   ├─→ 创建 QbbNetDevice
│   │   ├─→ 创建 QbbChannel
│   │   └─→ 设置链路参数 (带宽、延迟、错误率)
│   │
│   ├─→ 分配IP地址
│   │   └─→ node_id_to_ip() [第156行]
│   │
│   └─→ 记录邻居信息
│       └─→ 更新 nbr2if 映射表
│
└─→ 配置交换机 (第974-1004行)
    ├─→ SwitchMmu::ConfigEcn()      [配置ECN阈值]
    ├─→ SwitchMmu::ConfigHdrm()     [配置PFC headroom]
    └─→ SwitchMmu::ConfigBufferSize() [配置缓冲区大小]

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段3: RDMA初始化                                                        │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
└─→ 为每个主机安装RDMA (第1007-1051行)
    │
    ├─→ CreateObject<RdmaHw>()
    │   └─→ 设置拥塞控制参数
    │
    ├─→ CreateObject<RdmaDriver>()
    │   ├─→ RdmaDriver::SetNode()
    │   ├─→ RdmaDriver::SetRdmaHw()
    │   └─→ node->AggregateObject(rdma)
    │
    └─→ RdmaDriver::Init() [rdma-driver.cc:21]
        │
        ├─→ 为每个网络接口创建 RdmaInterfaceMgr
        ├─→ 创建 RdmaQueuePairGroup
        └─→ RdmaHw::Setup()
            └─→ 设置回调函数

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段4: 路由计算                                                          │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ CalculateRoutes(n) [第376行]
│   │
│   └─→ for each host:
│       └─→ CalculateRoute(host) [第329行]
│           │
│           ├─→ BFS遍历网络拓扑
│           ├─→ 计算 pairDelay (延迟)
│           ├─→ 计算 pairTxDelay (传输延迟)
│           ├─→ 计算 pairBw (带宽，取路径最小值)
│           └─→ 记录 nextHop (下一跳)
│
├─→ SetRoutingEntries() [第384行]
│   │
│   └─→ for each node:
│       ├─→ SwitchNode::AddTableEntry()  [交换机]
│       └─→ RdmaHw::AddTableEntry()      [主机]
│
└─→ 计算BDP和RTT (第1064-1086行)
    ├─→ 计算 pairRtt[i][j] = delay * 2 + txDelay
    ├─→ 计算 pairBdp[i][j] = rtt * bw / 1e9 / 8
    └─→ 更新全局 maxRtt 和 maxBdp

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段5: 应用启动                                                          │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ 初始化端口号 (第1139-1146行)
│
└─→ ScheduleFlowInputs() [第136行]
    │
    ├─→ ReadFlowInput() [第130行]
    │   └─→ 从 flowf 读取: src, dst, pg, dport, maxPacketCount, start_time
    │
    └─→ 当流启动时间到达时:
        │
        ├─→ RdmaClientHelper::Install() [创建应用]
        │   │
        │   └─→ ApplicationContainer::Start(Time(0))
        │       │
        │       └─→ RdmaClient::StartApplication() [rdma-client.cc:135]
        │           │
        │           └─→ RdmaDriver::AddQueuePair()
        │               │
        │               └─→ RdmaHw::AddQueuePair() [rdma-hw.cc:248]
        │                   │
        │                   ├─→ CreateObject<RdmaQueuePair>()
        │                   ├─→ 设置队列对参数
        │                   ├─→ 初始化拥塞控制状态
        │                   │   ├─→ CC_MODE=1: qp->mlx.m_targetRate
        │                   │   ├─→ CC_MODE=3: qp->hp.m_curRate
        │                   │   └─→ CC_MODE=10: qp->hpccPint.m_curRate
        │                   └─→ QbbNetDevice::NewQp()

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段6: 监控和追踪设置                                                    │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ QbbHelper::EnableTracing() [包级追踪]
│
├─→ Simulator::Schedule(monitor_buffer_new) [队列长度监控]
│   └─→ monitor_buffer_new() [第215行]
│       ├─→ 监控NIC RTT
│       ├─→ 监控交换机吞吐量
│       └─→ 监控队列长度
│
├─→ Simulator::Schedule(monitor_sketch) [Sketch监控]
│   └─→ monitor_sketch() [第279行]
│       └─→ SwitchNode::reportSketch()
│
└─→ Simulator::Schedule(parameter_tuning) [参数调优]
    └─→ parameter_tuning() [第311行]
        ├─→ RdmaHw::ChangeParameters() [主机]
        └─→ SwitchNode::ChangeECNthreshold() [交换机]

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段7: 仿真运行                                                          │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ Simulator::Stop(Seconds(simulator_stop_time))
│
└─→ Simulator::Run() [NS-3事件循环]
    │
    ├─→ 事件1: ScheduleFlowInputs()
    │   └─→ 启动流应用
    │
    ├─→ 事件2: 数据包发送
    │   │
    │   └─→ QbbNetDevice::DequeueAndTransmit() [qbb-net-device.cc:258]
    │       │
    │       ├─→ RdmaEgressQueue::GetNextQindex() [选择队列]
    │       ├─→ RdmaEgressQueue::DequeueQindex() [出队]
    │       └─→ QbbNetDevice::TransmitStart()
    │           │
    │           └─→ QbbChannel::TransmitStart()
    │               │
    │               └─→ 对端 QbbNetDevice::Receive()
    │
    ├─→ 事件3: 数据包接收
    │   │
    │   └─→ QbbNetDevice::Receive() [qbb-net-device.cc:350]
    │       │
    │       ├─→ 如果是PFC帧:
    │       │   └─→ 设置 m_paused[qIndex] = true/false
    │       │
    │       └─→ 如果是数据包:
    │           ├─→ 交换机: SwitchNode::SwitchReceiveFromDevice()
    │           │   │
    │           │   ├─→ SwitchNode::GetOutDev() [路由查找]
    │           │   ├─→ SwitchMmu::CheckIngressAdmission() [准入控制]
    │           │   ├─→ SwitchMmu::CheckEgressAdmission()
    │           │   ├─→ SwitchNode::CheckAndSendPfc() [PFC检查]
    │           │   └─→ QbbNetDevice::SwitchSend()
    │           │
    │           └─→ 主机: RdmaHw::Receive() [rdma-hw.cc]
    │               │
    │               ├─→ 如果是ACK:
    │               │   └─→ RdmaHw::ProcessAck()
    │               │       │
    │               │       ├─→ 根据CC_MODE更新速率
    │               │       │   ├─→ HPCC: 根据INT信息计算新速率
    │               │       │   └─→ 更新 RdmaQueuePair::m_rate
    │               │       │
    │               │       └─→ 如果流完成:
    │               │           └─→ qp_finish() [third.cc:164]
    │               │               └─→ 写入FCT文件
    │               │
    │               └─→ 如果是数据包:
    │                   └─→ 创建/更新 RxQp
    │
    ├─→ 事件4: 拥塞控制更新
    │   │
    │   └─→ RdmaHw::UpdateNextAvail()
    │       └─→ 根据拥塞控制算法更新发送速率
    │
    ├─→ 事件5: PFC处理
    │   │
    │   └─→ SwitchNode::CheckAndSendPfc() [switch-node.cc:122]
    │       │
    │       ├─→ SwitchMmu::CheckShouldPause()
    │       └─→ QbbNetDevice::SendPfc()
    │
    └─→ 事件6: 监控任务
        ├─→ monitor_buffer_new()
        ├─→ monitor_sketch()
        └─→ parameter_tuning()

┌─────────────────────────────────────────────────────────────────────────┐
│ 阶段8: 清理和输出                                                        │
└─────────────────────────────────────────────────────────────────────────┘

main()
│
├─→ Simulator::Destroy() [清理资源]
│
├─→ fclose(trace_output)
├─→ fclose(qlen_output)
└─→ 输出执行时间

================================================================================
                        关键函数调用链
================================================================================

1. 流启动流程:
   ScheduleFlowInputs()
   → ReadFlowInput()
   → RdmaClientHelper::Install()
   → RdmaClient::StartApplication()
   → RdmaDriver::AddQueuePair()
   → RdmaHw::AddQueuePair()
   → QbbNetDevice::NewQp()

2. 数据包发送流程:
   RdmaQueuePair (应用层)
   → RdmaHw::SendPkt()
   → QbbNetDevice::SwitchSend()
   → BEgressQueue::Enqueue()
   → QbbNetDevice::DequeueAndTransmit()
   → QbbNetDevice::TransmitStart()
   → QbbChannel::TransmitStart()
   → 对端 QbbNetDevice::Receive()

3. 拥塞控制流程 (HPCC):
   数据包经过交换机
   → SwitchMmu::CheckIngressAdmission() / CheckEgressAdmission()
   → 如果队列长度超过阈值 → 设置ECN标记
   → 接收端收到带ECN标记的ACK
   → RdmaHw::ProcessAck()
   → 根据INT信息计算新速率
   → 更新 RdmaQueuePair::m_rate

4. PFC流程:
   交换机队列长度超过PFC阈值
   → SwitchMmu::CheckShouldPause()
   → SwitchNode::CheckAndSendPfc()
   → QbbNetDevice::SendPfc()
   → 对端 QbbNetDevice::Receive()
   → 设置 m_paused[qIndex] = true
   → 暂停该优先级队列的发送

================================================================================
                        关键数据结构
================================================================================

全局变量 (third.cc):
- NodeContainer n: 所有节点
- map<Ptr<Node>, map<Ptr<Node>, Interface> > nbr2if: 邻居接口映射
- map<Ptr<Node>, map<Ptr<Node>, vector<Ptr<Node> > > > nextHop: 路由下一跳
- map<Ptr<Node>, map<Ptr<Node>, uint64_t> > pairDelay: 节点对延迟
- map<Ptr<Node>, map<Ptr<Node>, uint64_t> > pairBw: 节点对带宽
- map<uint32_t, map<uint32_t, uint64_t> > pairRtt: 节点对RTT
- map<uint32_t, map<uint32_t, uint64_t> > pairBdp: 节点对BDP

核心类:
- RdmaQueuePair: RDMA队列对，包含拥塞控制状态
- RdmaHw: RDMA硬件抽象，实现拥塞控制算法
- RdmaDriver: RDMA驱动接口
- QbbNetDevice: 支持PFC的网络设备
- SwitchNode: 交换机节点，实现路由和PFC
- SwitchMmu: 交换机内存管理单元

================================================================================

