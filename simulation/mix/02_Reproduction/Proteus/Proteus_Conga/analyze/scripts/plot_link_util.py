#!/usr/bin/env python3
"""Visualize link utilization traces from a mix run.

This version produces two separate figures: throughput and utilization.
Use `--include` to filter specific port labels (e.g. H0-1 S2-1).
If `--output` is provided it will produce two files with suffixes
"_throughput" and "_utilization" (or place in a directory).
"""

from collections import defaultdict
from pathlib import Path
import argparse
from typing import Optional, Set, Tuple

import matplotlib.pyplot as plt


def parse_switch_nodes(topology_path: Path) -> set[int]:
    lines = [
        line
        for line in topology_path.read_text().splitlines()
        if line.strip() and not line.strip().startswith("#")
    ]
    if len(lines) < 2:
        raise ValueError("Topology file must contain at least two non-comment lines")
    try:
        switch_ids = {int(token) for token in lines[1].split()}
    except ValueError as exc:
        raise ValueError("Unable to parse switch IDs from second line") from exc
    return switch_ids


def build_port_label(node_id: int, port_id: int, switch_nodes: set[int]) -> str:
    prefix = "S" if node_id in switch_nodes else "H"
    return f"{prefix}{node_id}-{port_id}"


def parse_link_util(data_path: Path, switch_nodes: set[int]) -> dict[str, dict[str, list[float]]]:
    per_port = defaultdict(lambda: {"times": [], "throughput": [], "util": []})
    current_time: Optional[int] = None
    for raw_line in data_path.read_text().splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("time:"):
            current_time = int(line.split("time:", 1)[1].strip())
            continue
        if current_time is None:
            continue
        tokens = line.split()
        if len(tokens) < 5:
            continue
        node_id, port_id = int(tokens[0]), int(tokens[1])
        tx, util = float(tokens[3]), float(tokens[4])
        label = build_port_label(node_id, port_id, switch_nodes)
        bucket = per_port[label]
        bucket["times"].append(current_time)
        bucket["throughput"].append(tx)
        bucket["util"].append(util)
    return per_port


def plot_throughput(port_data: dict[str, dict[str, list[float]]], include_labels: Optional[Set[str]] = None) -> plt.Figure:
    fig, ax = plt.subplots(1, 1, figsize=(12, 4))
    for label in sorted(port_data.keys()):
        if include_labels and label not in include_labels:
            continue
        series = port_data[label]
        if not series["times"]:
            continue
        linestyle = "-" if label.startswith("H") else "--"
        ax.plot(series["times"], series["throughput"], label=label, linestyle=linestyle)
    ax.set_ylabel("Throughput (Gbps)")
    ax.set_title("Per-port throughput")
    ax.set_xlabel("Time (ns)")
    ax.grid(True, linestyle="--", alpha=0.4)
    ax.legend(title="Port")
    fig.tight_layout()
    return fig


def plot_utilization(port_data: dict[str, dict[str, list[float]]], include_labels: Optional[Set[str]] = None) -> plt.Figure:
    fig, ax = plt.subplots(1, 1, figsize=(12, 4))
    for label in sorted(port_data.keys()):
        if include_labels and label not in include_labels:
            continue
        series = port_data[label]
        if not series["times"]:
            continue
        linestyle = "-" if label.startswith("H") else "--"
        ax.plot(series["times"], series["util"], label=label, linestyle=linestyle)
    ax.set_ylabel("Link utilization (%)")
    ax.set_title("Per-port link utilization")
    ax.set_xlabel("Time (ns)")
    ax.grid(True, linestyle="--", alpha=0.4)
    ax.legend(title="Port")
    fig.tight_layout()
    return fig


def make_output_paths(out: Optional[Path]) -> Tuple[Optional[Path], Optional[Path]]:
    if out is None:
        return None, None
    if out.exists() and out.is_dir():
        return out / "link_util_throughput.png", out / "link_util_utilization.png"
    if out.suffix:
        stem = out.stem
        parent = out.parent
        return parent / f"{stem}_throughput{out.suffix}", parent / f"{stem}_utilization{out.suffix}"
    parent = out.parent if out.parent != Path(".") else Path(".")
    name = out.name
    return parent / f"{name}_throughput.png", parent / f"{name}_utilization.png"


def main() -> None:
    parser = argparse.ArgumentParser(description="Plot link utilization traces from mix simulations.")
    
    # Get script directory to build relative paths
    base_dir = Path(__file__).resolve().parent.parent.parent
    
    parser.add_argument("--topology", type=Path, default=base_dir / "config" / "topology_h22_s4.txt", help="Topology file that lists the switch node IDs on the second line.")
    parser.add_argument("--data", type=Path, default=base_dir / "output" / "link_util.txt", help="Link utilization monitor file generated by the simulation.")
    parser.add_argument("--output", type=Path, default=base_dir / "analyze" / "figures", help="Optional path (file base or directory) to save the two figures.")
    parser.add_argument("--include", nargs="*", help=("Optional list of port labels to keep, e.g. H0-1 S2-1." " Labels follow the prefix+node-port format used in the plot."))
    args = parser.parse_args()

    try:
        switch_nodes = parse_switch_nodes(args.topology)
    except ValueError as exc:
        raise SystemExit(f"Failed to read topology: {exc}") from exc

    port_data = parse_link_util(args.data, switch_nodes)
    if not port_data:
        raise SystemExit("No port data was loaded from the link utilization file.")

    include_labels = set(args.include) if args.include else None

    out_tp, out_ut = make_output_paths(args.output)

    fig_tp = plot_throughput(port_data, include_labels)
    fig_ut = plot_utilization(port_data, include_labels)

    if args.output:
        out_tp.parent.mkdir(parents=True, exist_ok=True)
        fig_tp.savefig(out_tp, dpi=150)
        fig_ut.savefig(out_ut, dpi=150)
        print(f"Wrote throughput figure to {out_tp}")
        print(f"Wrote utilization figure to {out_ut}")
    else:
        # fig_tp.show()
        # fig_ut.show()
        print("No output path provided, and interactive show is disabled.")


if __name__ == "__main__":
    main()
